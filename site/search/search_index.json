{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-]","pipeline":["stemmer"]},"docs":[{"location":"","title":"\u9996\u9875","text":"<p> \u200b\u7ea6\u200b 31 \u200b\u4e2a\u200b\u5b57\u200b  1 \u200b\u5f20\u200b\u56fe\u7247\u200b  \u200b\u9884\u8ba1\u200b\u9605\u8bfb\u200b\u65f6\u95f4\u200b\u4e0d\u5230\u200b 1 \u200b\u5206\u949f\u200b</p> <p>\u200b\u6b22\u8fce\u200b\uff01</p> <p>\u200b\u4f1a\u200b\u8bb0\u5f55\u200b\u4e00\u4e9b\u200b\u7b14\u8bb0\u200b\u3001\u200b\u5c0f\u200b\u6280\u80fd\u200b\u4ee5\u53ca\u200b\u4e00\u4e9b\u200bproject\u200b\u5427\u200b\uff08\u200b\u53cd\u6b63\u200b\u57fa\u672c\u200b\u4e5f\u200b\u662f\u200b\u7ed9\u200b\u6211\u200b\u81ea\u5df1\u200b\u770b\u200b\uff09</p> <p></p>"},{"location":"blog/","title":"\u8bfe\u7a0b\u200b\u7b14\u8bb0","text":"<p> \u200b\u7ea6\u200b 43 \u200b\u4e2a\u200b\u5b57\u200b  \u200b\u9884\u8ba1\u200b\u9605\u8bfb\u200b\u65f6\u95f4\u200b\u4e0d\u5230\u200b 1 \u200b\u5206\u949f\u200b</p> <p>\u200b\u81ea\u5df1\u200b\u4e0a\u8bfe\u200b\u8bb0\u5f97\u200b\u4e00\u4e9b\u200b\u7b14\u8bb0\u200b\u3002\u200b\u57fa\u672c\u4e0a\u200b\u90fd\u200b\u662f\u200b\u4e9b\u200b\u5b66\u957f\u200b\u4eec\u200b\u6ca1\u200b\u4e0a\u200b\u8fc7\u200b\u7684\u200b\u8bfe\u200b\u5427\u200b()\u3002</p> <p>Isshiki\u200b\u4fee\u200b's Notebook\uff1ahttps://note.isshikih.top/</p> <p>\u200b\u54b8\u9c7c\u200b\u6684\u200b\u7684\u200b\u4ee3\u7801\u200b\u7a7a\u95f4\u200b\uff1ahttps://xuan-insr.github.io/</p>"},{"location":"cryption/","title":"\u6570\u636e\u5b89\u5168\u200b\u4e0e\u200b\u5bc6\u7801\u5b66\u200b\u57fa\u7840","text":"<p> \u200b\u7ea6\u200b 72 \u200b\u4e2a\u200b\u5b57\u200b  \u200b\u9884\u8ba1\u200b\u9605\u8bfb\u200b\u65f6\u95f4\u200b\u4e0d\u5230\u200b 1 \u200b\u5206\u949f\u200b</p> <p>\u200b\u8fd9\u8282\u200b\u8bfe\u200b\u4e0d\u662f\u200b\u5168\u82f1\u200b\u7684\u200b()\uff0c\u200b\u4f46\u662f\u200b\u56e0\u4e3a\u200b\u6211\u7528\u200b\u82f1\u6587\u200b\u6559\u6750\u200b\u770b\u200b\u7684\u200b\u6240\u4ee5\u200b\u8fd8\u662f\u200b\u7528\u200b\u5168\u82f1\u6587\u200b\u5199\u200b\u7684\u200b\uff0c\u200b\u4e0d\u8fc7\u200b\u5e94\u8be5\u200b\u8fd8\u662f\u200b\u6bd4\u8f83\u7b80\u5355\u200b\u6613\u61c2\u200b\u7684\u200b\uff08\u200b\u5927\u6982\u200b\uff09\uff0c\u200b\u6bd4\u8f83\u200b\u96be\u770b\u200b\u61c2\u200b\u7684\u200b\u5730\u65b9\u200b\u90fd\u200b\u7528\u200b\u4e2d\u6587\u200b\u6ce8\u91ca\u200b\u51fa\u6765\u200b\u4e86\u200b\u3002</p>"},{"location":"cryption/C2/","title":"Perfectly Secret Encryption","text":"<p> \u200b\u7ea6\u200b 34 \u200b\u4e2a\u200b\u5b57\u200b  \u200b\u9884\u8ba1\u200b\u9605\u8bfb\u200b\u65f6\u95f4\u200b\u4e0d\u5230\u200b 1 \u200b\u5206\u949f\u200b</p> <ol> <li>definition: meet as following:</li> <li>the adversary knows the likelihood that different messages will be sent and the encryption scheme be used.</li> <li>the key is unknown.</li> <li>ciphertext-only attack(only know the ciphertext)</li> </ol>"},{"location":"cryption/C3/","title":"Private-Key Encryption","text":"<p> \u200b\u7ea6\u200b 4921 \u200b\u4e2a\u200b\u5b57\u200b  \u200b\u9884\u8ba1\u200b\u9605\u8bfb\u200b\u65f6\u95f4\u200b 16 \u200b\u5206\u949f\u200b</p>"},{"location":"cryption/C3/#computational-security","title":"Computational Security","text":"<ul> <li>Background: Perfectly secrecy demands no messages leak from the ciphertext. But for practical purpose, an encryption scheme is still considered secure if it leaked information with some tiny probability to eavesdropper with bounded computational power.</li> <li>definition:<ul> <li>take adversary's computational power limits into account.</li> <li>allow for a small probability that secure is violated.</li> <li>given enough time (or sufficient computational resources) an attacker may be able to violate the security.</li> <li>adversary can succeed with some very small probability.</li> </ul> </li> </ul> <p>relaxtions of perfect secrecy: computational secrecy is (1) guaranteed only against effcient adversary, (2) secrecy may 'fail' with small probability.</p>"},{"location":"cryption/C3/#the-concrete-approach","title":"The Concrete Approach","text":"<ol> <li>definition: maximum success probability of an adversary running for some specified amount of time or investing some specified amount of computational effort. </li> <li>Form: A scheme is (t,\u025b)-secure if any adversary running for time at most t succeeds in breaking the scheme with probability at most \u025b. \u200b\u610f\u4e3a\u200b\u5728\u200b\u7ed9\u5b9a\u200b\u7684\u200b\u65f6\u95f4\u200b\u5185\u200b\uff0c\u200b\u653b\u51fb\u8005\u200b\u4e0d\u80fd\u200b\u4ee5\u200b\u8d85\u8fc7\u200b\u025b\u200b\u7684\u200b\u6982\u7387\u200b\u6253\u7834\u200b\u5b89\u5168\u6027\u200b\u3002 <p>example: The length of key is n, then the key space is \\(2^n\\). For an adversary running for t, breaking the scheme with probability at most \\(ct/2^n\\) for a fixed constant c.</p> <p>the minimum length of key is n = 128.</p> </li> </ol>"},{"location":"cryption/C3/#the-asymptotic-approach","title":"The Asymptotic Approach","text":"<ul> <li> <p>security parameter(denoted by n):</p> <ul> <li>parties choose some value for the parameter(corresponding to the length of key)</li> <li>running time for an adversary as well as its success probability, as functions of the security parameter rather than as fixed, concrete value.</li> </ul> </li> <li> <p>definition: </p> <ul> <li>efficient adversary: with randomized algorithms running in time polynomial in n(the honestest parties run in polynomial time).</li> <li>\"small probabilities of success\"(negligible): with success probabilities smaller than any inverse polynomial in n.</li> </ul> </li> <li>Form(PPT for \"probabilistic polynomial-time\"): A scheme is secure if any PPT adversary succeeds in breaking the scheme with at most negligible probability. <p>example1: The security parameter n determines the time the adversary uses and probability. Increasing security also increases the time required to run the scheme, as well as the length of the key.</p> <p>example2: When the computational power improve, the honestest parties can also increase the security parameter so that makes adversary's job harder.</p> </li> </ul> <p>An asymptotic encryption can be translated into a concrete security bound for any desired value n.</p> <ol> <li>efficient algorithms: <ul> <li>function f from natural numbers to the non-negative real numbers is polynomial if there is a constant c such that \\(f(n) &lt; n^c\\) for all n.</li> <li>algorithm A runs in polynomial time if there exists a polynomial p such that for every input \\(x \\in \\{0, 1\\}^*\\), the computation of A(x) terminates within at most p(|x|) steps.</li> <li>input can be security parameter and others such as message to be encrypted.</li> <li>obey closure properties. \\(p(n) = p_1(p_2(n))\\) is also polynomial.</li> <li>all algorithms are probabilistic, and have access to unbiased, independent random bits. A randomized algorithm is given a uniformly distributed random tape of sufficient length whose bits it can use, as needed, throughout its execution.<ul> <li>randomness is essential to encryption, the honestest parties and adversaries must be probabilistic.</li> <li>randomization is practical and gives the attacker additional power.</li> </ul> </li> </ul> </li> <li>negligible success probability: negligible function is one that is asymptotically smaller than any inverse polynomial function.<ul> <li>definition: function f from the natural numbers to non-negative real numbers is negligible if for every polynomial p there is an N such that for all n &gt; N it holds that \\(f(n) &lt; \\frac{1}{p(n)}\\).</li> <li>obey closure properties:<ul> <li>\\(negl_3(n) = negl_1(n) + negl_2(n)\\)</li> <li>\\(negl_4(n) = p(n) \\cdot negl_1(n)\\), demonstrate that a negligible event is also negligible even repeated in polynomial times.</li> </ul> </li> <li>'n &gt; N' defines that n is big enough. While \\(n \\leq N\\), nothing is guaranteed.</li> </ul> </li> <li>advantages of polynomial time algorithms:<ul> <li>free us from having to specify our model of computation precisely.</li> <li>satisfy the desirable closure properties.</li> </ul> </li> </ol> <p>nesscity of relaxtion: for an adversary who can attack with known-plaintext attack(it means |M| &gt; |K|), then the adversary can learn ciphertexts \\(c_1, c_2, ...\\) corresponding to messages \\(m_1, m_2, ...\\) repectively. So the adversary can guess the key using brute force attack, and the adversary can succeed only in probability 1/|K| because the K space is |K| and the adversary doesn't know the key.</p> <p>the adversary can succeed with time O(|K|), but |K| is large enough.</p>"},{"location":"cryption/C3/#computational-security-encryption","title":"Computational Security Encryption","text":"<ul> <li>redefine the syntax of private-key encryption, now we take into account the security parameter n.</li> <li>allow the encryption output an error.</li> <li>let the message space be the set \\(\\{0, 1\\}^*\\) of all binary strings by default.</li> <li>definition: consists of three probabilistic polynomial-time algorithms (Gen, Enc, Dec) such that:<ul> <li>Gen takes as input \\(1^n\\)(the security parameter written in unary). Gen is a rondomized algorithm. We assume that without loss of generality that any key k output by \\(Gen(1^n)\\) satisfies |k| &gt; n.</li> <li>Enc takes an input k and a plaintext message \\(m \\in \\{0, 1\\}^*\\), and output a ciphertext c. Enc algorithm is randomized.</li> <li>Dec takes an input k and ciphertext c, and outputs a message \\(m \\in \\{0, 1\\}^*\\) or an error. Denote a generic error by the symbol \u22a5(assume Dec is a deterministic algorithm).</li> <li>If (Gen, Enc, Dec) is such that for k output by \\(Gen(1^n)\\), algorithm \\(Enc_k\\) is only defined for messages \\(m \\in \\{0, 1\\}^{l(n)}\\), then we say that (Gen, Enc, Dec) is a fixed-length private-key encryption scheme for messages of length l(n).</li> </ul> </li> </ul>"},{"location":"cryption/C3/#the-basic-definition-of-security-eav-security","title":"The Basic Definition of Security (EAV-Security)","text":"<p>security against a ciphertext attack adversary only observe a single cipertext or security when a giver key is used to encrypt just a single message.</p> <p>New \\(PrivK^{eav}_{A, \u03a0}(n)\\):    1. adversaries running in polynomial time instead of unbounded running time.   2. adversaries determine the encrypted message with probability negligibly better than \u00bd.   3. explicitly require the adversaries output two messages \\(m_0, m_1\\) of equal length(no need a secure encryption scheme to hide the length of plaintext).</p> <ul> <li>Indistinguishablility in the presence of an eavesdropper: <ol> <li>The adversary A is given input \\(1^n\\), and outputs a pair of messages \\(m_0, m_1 \\in \\{0, 1\\}^{l(n)}\\), with the same length.</li> <li>K is generated by running \\(Gen(1^n)\\), and a uniform bit \\(b \\in \\{0, 1\\}\\) is chosen. Ciphertext \\(c(challenge\\ ciphertext) \u2190 Enc(m_b)\\) is computed and given to A.</li> <li>A outputs a bit \\(b'\\).</li> <li>The result is 1 if b = b', and 0 otherwise. \\(PrivK^{eav}_{A, \u03a0}(n) = 1\\) means A succeeds.  Definition: A private-key encryption scheme \\(\u03a0 = (Gen, Enc, Dec)\\) has indistinguishablility in the presence of an eavesdropper(EAV secure), if for all PPT adversaries there is a negligible function that, for all n:(randomness of A, choose of b and k, and Enc, .etc)</li> </ol> </li> </ul> \\[ Pr[PrivK^{eav}_{A, \u03a0}(n) = 1] \u2264 1/2 + negl(n) \\] <ul> <li>An equivalent formulation: every PPT adversaries behave same wether it observes an encryption of \\(m_0\\ and\\ m_1\\). Let \\(out_A(PrivK^{eav}_{A, \u03a0}(n, b))\\) denote the output b' of A, A is not significantly affected by wether b = 1 or 0.       Definition: A private-key encryption scheme has indistinguishablility in the presence of an eavesdropper(EAV secure) if for all PPT adversaries A there is a negligible function negl such that:    $$    |Pr[out_A(PrivK^{eav}{A, \u03a0}(n, 1))=1] - Pr[out_A(PrivK^{eav}(n, 0))=1]| \u2264 negl(n)    $$</li> </ul>"},{"location":"cryption/C3/#revealing-the-plaintext-length","title":"Revealing the Plaintext Length","text":"<p>Although EAV-secure doesn't hidden the length of plaintext, but sometimes the length of plaintext can leak some information.</p> <p>So for the condition length can leak the information, we need to mitigate or prevent such leakage by padding all messages to some pre-determined length before encrypting them.</p>"},{"location":"cryption/C3/#semantic-security","title":"Semantic Security","text":"<ul> <li>Definition: ciphertext leak no information about individual bits of the plaintext. It means for an EVA security scheme, for any i it is infeasible for an attacker given the ciphertext to guess the \\(i_{th}\\) bit of m with probability much better than \u00bd.</li> <li>Theorem: Let \u03a0 = (Enc, Dec) be a fixed-length private-key encryption scheme for messages of length l that is EAV-secure. Then for all PPT adversaries A and \\(i \\in \\{1, ..., l\\}\\), there is a negligible function negl such that (randomness of A and Enc) $$ Pr[A(1^n, Enc(m)) = m^i] \u2264 \u00bd + negl(n), $$ <p>Hint: use \\(Pr[PrivK^{eav}_{A, \u03a0}(n) = 1] = Pr[A(1^n, Enc_k(m_b)) = b]\\) to proof.</p> </li> </ul> <p>Mention that an attacker can not find the message from the ciphertext even if the attacker know about the distribution D of the m. (distribution\u200b\u662f\u200b\u6307\u200bmessage\u200b\u7684\u200b\u5206\u5e03\u200b\u89c4\u5f8b\u200b\u3002\u200b\u6bd4\u5982\u200b\u67d0\u4e2a\u200b\u8bcd\u8bed\u200b\u6216\u8005\u200b\u5b57\u6bcd\u200b\u7684\u200b\u4f7f\u7528\u200b\u9891\u7387\u200b)</p> <ul> <li>Theorem: Let \u03a0 = (Enc, Dec) be a fixed-length private-key encryption scheme for messages of length l that is EAV-secure. For any PPT algorithm A there exits a PPT algotithm A' such that for any distribution D over \\(\\{0, 1\\}^l\\) and any function f: \\(\\{0, 1\\}^l \u2192 \\{0, 1\\}\\), there is a negligible function that: $$ |Pr[A(1^n, Enc_K(m)) = f(m)] - Pr[A'(1^n) = f(m)]|  \u2264 negl(n) $$</li> </ul> <p>It means that we distinguish the probability that A know the f(m) through the distribution D when the attacker know the f(m).</p> <p>Hint: we can prove this by proving the adversary A can not distinguish between Enc(m), when m is chosen by distribution of M, and Enc(\\(1^l\\)), where \\(1^l\\) is a string of all 1.</p> <ul> <li>New Semantic Security Definition: let arbitrary distributions over messages, generated by some polynomial algorithms Samp; also take into account \"external\" formation h(m) about the message that may be available to the adversaries via other means; the length of the message is variable.</li> </ul> <p>Definition: A private-key security scheme is semantically secure in the presence of an eavesdropper if for any PPT algorithms A there is a PPT algorithm A' such that for any PPT algorithm Samp and polynomial-time computable functions f and h, the following is negligible:    $$    |Pr[A(1^n, Enc_k(m), h(m) = f(m))] - Pr[A'(1^n, |m|, h(m) = f(m))]|    $$</p> <ul> <li>Theorem: A private-key encryption scheme has a indistinguishable encryption in the presence of an eavesdropper (EVA-secure) if and only if it is semantically secure in the presence of an eavesdropper.</li> </ul>"},{"location":"cryption/C3/#constructing-an-eav-secure-encryption-scheme","title":"Constructing an EAV-secure Encryption Scheme","text":""},{"location":"cryption/C3/#pseudorandom-generators-prg","title":"Pseudorandom Generators (PRG)","text":"<p>Pseudorandom generator use a small true randomness in order to generate a amount of pseudorandom.And pseudorandomness is a property of the distribution of the string, it is different from the uniform string. </p> <p>Pseudorandom is a relaxtion of true randomness.</p> <ul> <li>Definition: Let G be a deterministic polynomial-time algorithm such that for any n and input \\(s \\in \\{0, 1\\}^n\\), the result of G(s) is a string of length l(n)(expansion factor of G). G is a pseudorandom generator if the following conditions holds:<ul> <li>Expansion: for every n l(n) &gt; n</li> <li>Pseudorandomness: for any PPT adversaries D, there is a negligible function that    $$    |Pr[D(G(s)) = 1] - Pr[D\u00ae = 1]| &lt;= negl(n)    $$    where G(s) is pseudorandom and r is a random string whose length is l(n).</li> </ul> </li> <li>Reduction(reduce the security level): A attack the security -&gt; A' solve the mathematic problem X. If A break the security, then A' can solve the X by a parameter x.<ol> <li>Fix some efficient attacker A attacking \u03a0. Denote this adversary's success probability by \u025b(n)</li> <li>Construct an efficient algorithm A' that attempts to solve the problem X by using adversary A as a subroutine (A' knows nothing about how A works; the only thing A' knows is that A is expecting to attack \u03a0). A' can solve the problem by x with the inverse polynomial probability 1/p(n).</li> <li>So A' solves the problem with the probability \u025b(n)/p(n). If \u025b(n) is not negligible then neither is \u025b(n)/p(n). So A is efficient then we obtain an efficient algorithm A' solving X with non-negligible probability, contradicting with the \"very hard mathematic problem\".</li> <li>So no efficient A can break the security scheme \u03a0. \u03a0 is computable security.</li> </ol> </li> </ul>"},{"location":"cryption/C3/#eva-security-from-a-pseudorandom-generatorind-eav","title":"EVA-Security from a Pseudorandom Generator(IND-EAV)","text":"<p>Use a pesudo-one-time pad to encrypt a message, and a computable bounded adversary can not distinguish it from true random one-time pad.</p> <ul> <li>Theorem: If G is a pseudorandom generator, then construction \u03a0: \\(Gen(1^n), Enc, Dec\\), and applying the algorithm G to the key in order to XOR with the plaintext, is an EVA-security, fixed length private-key encryption scheme for message of length l(n).</li> <li>The new role distinguisher D: D takes a string w as input, and whose goal is to determine wether w was chosen uniformly or generated by choosing a uniformly k and computing w = G(k).<ul> <li>Run \\(A(1^n)\\) to obtain a pair of messages \\(m_0, m_1 \\in \\{0, 1\\}^{l(n)}\\).</li> <li>Choose a uniform bit \\(b \\in \\{0, 1\\}\\). Set \\(c := w \\oplus m_b\\)</li> <li>Give c to A and obtain an output b'. Output 1 if b' = b, and output 0 otherwise.    And D observes A's result. If A wins, the D guess w must be a pseudorandom string, otherwise w is a random string.</li> </ul> </li> </ul> <p>Construction 3.17: Let G be a pseudorandom generator with expansion factor l(n). Define a fixed length private-key encryption scheme for messages of length l(n) as follows: + Gen: take input \\(1^n\\), choose uniform \\(k \\in \\{0, 1\\}^n\\) and output a key + Enc: take input k and message \\(m \\in \\{0, 1\\}^{l(n)}\\), output the ciphertext: $$ c := G(k) \\oplus m $$ + Dec: take input k and cipertext c, output message: $$ m := G(k) \\oplus c $$</p>"},{"location":"cryption/C3/#use-deduction-to-prove-construction-\u03c0-is-eav-security","title":"Use Deduction to Prove Construction \u03a0 is EAV-Security","text":"<p>Here is to show how to use reduction to prove. Assume that we have a distinguisher D, and a PPT adversary just like the former. We all know that when the security is one time pad, then $$ Pr[PrivK^{eav}{A, \u03a0}(n) = 1] = \\frac{1}{2} $$ Now we analyse the behaviour of D: 1. If w is chosen from \\(\\{0, 1\\}^{l(n)}\\), then the probability D wins is identical to A wins, because we have mentioned that D observes A's result to select output, so the reverse polynomial 1/p(n) = 1. So we have the equavalence as follows: $$ Pr}}[D(w) = 1] = Pr[PrivK^{eav{A, \u03a0}(n) = 1] = \\frac{1}{2} $$ 2. If a k is generated by \\(Gen(1^n)\\) and then setting \\(w:=G(k)\\), and the new secutiry scheme is \\(\\widetilde{\u03a0}\\), so the following equavalence is trival: $$ Pr}[D(G(n)) = 1] = Pr[PrivK^{eav{A, \\widetilde{\u03a0}}(n) = 1] $$ Since G is pseudorandom generator, so there is a negligible function: $$ |Pr[D(w) = 1]| \u2264 negl(n) \\ |Pr_{k\u2190{0, 1}^n}[D(G(n)) = 1] - \\frac{1}{2}| \u2264 negl(n)\\ Pr_{k\u2190{0, 1}^n}[D(G(n)) = 1] \u2264 negl(n) + \\frac{1}{2} \u2192 Pr[PrivK^{eav}_{A, \\widetilde{\u03a0}}(n) = 1] \u2264 negl(n) + \\frac{1}{2} $$ So it is a EVA-security.}[D(G(n)) = 1] - Pr_{w\u2190{0, 1}^{l(n)}</p>"},{"location":"cryption/C3/#concrete-security","title":"Concrete Security","text":"<p>We can adapt it by concrete security instead of asymptotic security. Assume G is a (t, \u025b)-pseudorandom (for the given value n to ensure t and \u025b are constant), so for all distinguishers D we have that $$ |Pr[D(G(s)) = 1] - Pr[D\u00ae=1]| \u2264 \u025b $$ Assume \u03a0 is (t - t', \u025b)-secure (t' is a small constant) for a PPT adversary A, A running for at most t-t' time (D is slower than A a little and t' is to ensure D is limited in t time), we have that: $$ Pr[PrivK^{eva}_{A, \u03a0} = 1] \u2264 \\frac{1}{2} + \u025b $$ </p>"},{"location":"cryption/C3/#stronger-security-notions","title":"Stronger Security Notions","text":""},{"location":"cryption/C3/#security-for-multiple-encryptions","title":"Security for Multiple Encryptions","text":"<p>Slove the question that the communicating parties send multiple messages using the same key.</p> <ul> <li>The multiple-message eavesdropping experiment \\(PrivK^{mult}_{A, \u03a0}(n)\\):<ol> <li>The adversary A is given input \\(1^n\\), and outputs a pair of equal-length lists of messages \\(\\vec{M_0} = (m_{0, 1}, ..., m_{0, t})\\) and \\(\\vec{M_1} = (m_{1, 1}, ..., m_{1, t})\\), with \\(|m_{0, t}| = |m_{1, t}|\\) for all i.</li> <li>A key K is generated by running \\(Gen(1^n)\\), and a uniform bit \\(b \\in \\{0, 1\\}\\) is chosen. For all i, the ciphertext \\(c_i \\leftarrow Enc_k(m_{b,i})\\) is computed and the list \\(\\vec{C} = (c_1, ..., c_t)\\) is given to A.</li> <li>A outputs a bit b'.</li> <li>The output of the experiment is defined to be 1 if b'=b, and 0 otherwise.</li> </ol> </li> <li> <p>Definition: indistinguishable multiple encryptions in the presence of an eavesdropper if for all PPT A: $$ Pr[PrivK^{mult}_{A, \u03a0}(n) = 1] \\leq \\frac{1}{2} + negl(n) $$</p> <p>Note: \\(PrivK^{eav}_{A, \u03a0}\\) is a special condition of \\(PrivK^{mult}_{A, \u03a0}\\) when all \\(m_{b,t}\\) is one-bit.</p> </li> <li> <p>Proposition: There is a encryption scheme that has indistinguishable encryption in the presence of an eavesdropper but has no indistinguishable multiple encryptions in the presence of eavesdropper (such as one-time pad).</p> <p>Proof: Assume \\(\\vec{M_0} = (0^l, 0^l), \\vec{M_1} = (0^l, 1^l), \\vec{C} = (c_1, c_2)\\), A output b'=1 if \\(c_1 \\neq c_2\\), output b'=0 if \\(c_1 = c_2\\).</p> </li> <li> <p>Theorem: If \u03a0 is a encryption scheme which Enc is a deterministic function, then \u03a0 can not have indistinguishable multiple encryptions in the presence of an eavesdropper.</p> </li> </ul>"},{"location":"cryption/C3/#chosen-plaintext-attacks-and-cpa-security","title":"Chosen-Plaintext Attacks and CPA-Security","text":"<ul> <li>CPA-security: we model chosen-plaintext attacks by giving the adversary A access to an encryption oracle, viewed as a \"black box\" that encrypts messages of A's choice using a key that is unknown to A. The adversary can interact with the encryption oracle adaptively, as many as times it likes.     \\(PrivK^{cpa}_{A, \u03a0}(n)\\):<ol> <li>A key k is generated by running \\(Gen(1^n)\\)</li> <li>The adversary A is given input \\(1^n\\) and oracle access to Enc(\u00b7), and outputs a pair of messages \\(m_0, m_1\\) of the same length.</li> <li>A uniform bit \\(b \\in \\{0, 1\\}\\) is chosen, and then a ciphertext \\(c \\leftarrow Enc_k(m_b)\\) is computed and given to A.</li> <li>The adversary A continues to have oracle access to \\(Enc_k(\u00b7)\\), and outputs a bit b'.</li> <li>The output of the experiment is defined to be 1 if b'=b, and 0 otherwise</li> </ol> </li> <li>Definition: A private-key encryption scheme \\(\u03a0=(Gen, Enc, Dec)\\) has indistinguishable encryption under a chosen-plaintext attack, or is CPA-secure, if for all probabilistic polynomial-time adversaries A there is a negligible function negl such that $$ Pr[PrivK^{cpa}_{A, \u03a0}(n) = 1] \\leq \\frac{1}{2} + negl(n) $$</li> </ul>"},{"location":"cryption/C3/#cpa-security-for-multiple-encryptions","title":"CPA-Security for Multiple Encryptions","text":"<p>Give the attacker access to a \"left-to-right\" oracle \\(LR_{k,b}\\), on input a pair of messages \\(m_0, m_1\\), computes the ciphertext \\(c \\leftarrow Enc_k(m_b)\\) and returns c. If b=0 then the adversary recieves an encryption of the \"left\" plaintext, and otherwise \"right\" plaintext.</p> \\[ PrivK^{LR-cpa}_{A, \u03a0}(n): $$   1. A key is generated by running $Gen(1^n).$   2. A uniform bit $b \\in \\{0, 1\\} is chosen$.   3. The adversary A is given input $1^n$ and oracle access to $LR_{k,b}(\u00b7,\u00b7)$, as defined above.   4. The adversary A outputs a bit b'.   5. The output of experiment is defined to be 1 if b'=b. + Definition: Private-key encryption scheme \u03a0 has **indistinguishable multiple encryptions under a chosen-plaintext attack**, or is **CPA-secure for multiple encryptions**, if for all PPT adversaries A there is a negligible function negl: $$ Pr[PrivK^{LR-cpa}_{A, \u03a0}(n) = 1] \\leq negl(n) + \\frac{1}{2} \\] <ul> <li>Theorem: Any private-key encryption scheme that is CPA-secure is also CPA-secure for multiple encryptions. <p>So a obvious advantage of CPA-secure for multiple messages is that we can treat fixed-length encryption without any loss of generality. So we can use a fixed-length encryption scheme to construct a arbitrary-length encryption scheme according to the Theorem.</p> </li> </ul>"},{"location":"cryption/C3/#constructing-a-cpa-secure-encryption-scheme","title":"Constructing a CPA-Secure Encryption Scheme","text":""},{"location":"cryption/C3/#pseudorandom-functions-and-permutations","title":"Pseudorandom Functions and Permutations","text":"<p>(\u200b\u5168\u662f\u200b\u75db\u82e6\u200b\u7684\u200b\u5927\u6bb5\u200b\u82f1\u6587\u200b\u63cf\u8ff0\u200b()) Pseudorandom functions (PRFs) generalize the notion of pseudorandom generators. We must consider the pseudorandomness of a distribution on functions. Such a distribution is induced natrually by considering keyed functions, defined next.</p> <p>A keyed function F: \\(\\{0, 1\\}^* \\times \\{0, 1\\}^* \\rightarrow \\{0, 1\\}^*\\) is two-input function, where the first input is called the key and typically called k. We say F is efficient if there is polynomial-time algorithm that computes F(k, x) given k and x. n is the secure parameter</p> <p>We associate with F three functions \\(l_{key}(n) = l_{in}(n) = l_{out}(n)\\); for any \\(key \\in \\{0, 1\\}^{l_{key}(n)}\\), the function \\(F_k\\) is only defined for input \\(x \\in \\{0, 1\\}^{l_{in}(n)}\\), in which case \\(F_k(x) \\in \\{0, 1\\}^{l_{out}(n)}\\). We assume F is length preserving, meaning \\(l_{key}(n) = l_{in}(n) = l_{out}(n) = n\\) (it is not necessary in the real world).</p> <p>When key is chosen and fixed, we are interested in the single-input function \\(F_k\\ :\\ \\{0, 1\\}^n \\rightarrow \\{0, 1\\}^n\\) defined by \\(F_k(x) \\overset{\\text{def}}= F(k, x)\\) mapping n-bit input strings to n-bit output strings. A keyed function F thus induced a distribution on functions in \\(Func_n\\), where the distribution is given by choosing a uniform key \\(k \\in \\{0, 1\\}^n\\) and then considering the resulting single-input function \\(F_k\\). We call F pseudorandom if the function \\(F_k\\) is indistinguishable from a function chosen uniformly at random from the set \\(Func_n\\) of all functions having the same domain and range.</p> <p>For a function f in the \\(Func_n\\), it can be viewed as look-up table, and x is the row of the table. So there is \\(2^n\\) rows in the table, and each row contains n-bit string. So any function in \\(Func_n\\) can be represented by a string of length \\(2^n \\cdot n\\). The correspondence is one-to-one as each string of length \\(2^n \\cdot n\\) defines a unique function in \\(Func_n\\). Thus, the size of \\(Func_n\\) is exactly the number of strings of length \\(2^n \\cdot n\\), \\(|Func_n| = 2^{n \\cdot 2^n}\\).</p> rows x x ... x f(x) (in \\(Func_n\\)) \\(\\{0, 1\\}^{l(n)}_0\\) \\(\\{0, 1\\}^{l(n)}_1\\) ... \\(\\{0, 1\\}^{l(n)}_{2^n-1}\\) <p>Now difine a distinguisher D, then D can not distinguish \\(F_k\\) from the uniformly function f in \\(Func_n\\). But it is incorrect because f has the exponential length. For a polynomial time distinguisher, D would not have sufficient time to examine the entire input.</p> <p>Instead, we allow D to probe the input/output behaviour of the function by giving D access to an oracle O which is either equal to f or \\(F_k\\). D may query its oracle at any point x, in response to which the oracle returns O(x). The oracle can be viewed as a blackbox, but it is a deterministic function.</p> <ul> <li>Definition: An efficient, length preserving, keyed function \\(F : \\{0, 1\\}^* \\times \\{0, 1\\}^* \\rightarrow \\{0, 1\\}^*\\) is a pseudorandom function if for all PPT distinguisher D, there is negligible function negl such that: $$ |Pr[D<sup>{F_k(\u00b7)}(1</sup>n)=1] - Pr[D<sup>{f(\u00b7)}(1</sup>n)=1]| \\leq negl(n) $$</li> </ul> <p>Mention that PRG and PRF are equivalent, the can construct from each other. For example: \\(G(s) \\overset{\\text{def}}= F_s(1)||F_s(2)||...||F_s(l)\\) for every l.(where || denotes concatenation)</p> <ul> <li> <p>Pseudorandom Permutations: Let \\(Perm_n \\subset Func_n\\) be the set of all permutations. Viewing \\(f \\in Perm_n\\) as a look-up table as before, we now added the constrait that the entries in any two distinct rows must be different. So the size of \\(Perm_n\\) is \\((2^n)!\\).    Let F be the keyed function where, for the moment, \\(l_{key}, l_{in}, l_{out}\\) can be arbitrary. We call F a keyed permutation if \\(l_{in} = l_{out}\\), we call \\(l_{in}\\) block length of F. \\(F_k\\) should be both efficiently computable and invertible given k if \\(F_k\\) is effcient.</p> </li> <li> <p>Proposition: If F is a pseudorandom permutation for which \\(l_{in}(n) \\geq n\\), then F is also a pseudorandom function.</p> <p>It is a asymptotically because concrete security may be impacted when a pseudorandom permutation  is viewed as a pseudorandom function.</p> </li> <li> <p>Strong Pseudorandom Permutations: As above, when given a oracle, it is possible for distinguisher D queries all function to find the difference between \\(F_k\\) and uniformly f.   Definition: Let \\(F : \\{0, 1\\}^* \\times \\{0, 1\\}^* \\rightarrow \\{0, 1\\}^*\\) be an efficient, length preserving, keyed permutation. F is a strong pseudorandomp permutation if for all probabilistic polynomial-time distinguishers D, there exists a negligible function negl:   $$   |Pr[D^{F_k(\u00b7), F_k<sup>{-1}(\u00b7)}(1</sup>n) = 1] - Pr[D<sup>{f_k(\u00b7),f_k</sup>(1^n) = 1]| \\leq negl(n)   $$}(\u00b7)</p> </li> </ul>"},{"location":"cryption/C3/#cpa-security-from-a-pseudorandom-functionind-cpa","title":"CPA-Security from a Pseudorandom Function(IND-CPA)","text":"<p>Because Pseudorandom Function is a deterministic algorithm, if we use \"\\(Enc_k(m) = F_k(m)\\)\", it is not CPA-secure since encryption the same plaintext twice will yield the same ciphertext.</p> <p>We can apply the pseudorandom function to a random value r and XORing the output with the plaintext. So encryption can be viewed as XORing a pseudorandom pad with the plaintext, with the major difference being the fact that here a fresh pseudorandom pad-that depends on r-is used ench time a message is encrypted (pseudorandom function has never been evaluated).</p> <p>This mode has the property that the ciphertext is longer than the plaintext.</p> <p>Proof based on pseudorandom function: consider a hypothetical version of the construction in which the pseudorandom function is replaced with a random function. It is then argued-using a proof by reduction-that this modification does not significantly affect the attacker's success probability. The rest of the proof typically relies on probabilistic analysis and doesn't rely on any computational assumptions.</p> <p>Construction 3.28</p> <p>Let F be a pseudorandom function. Define a fixed-length, private-key encryption scheme for messages of length n as follows: + Gen: on input \\(1^n\\), choose uniform \\(k \\in \\{0, 1\\}^n\\) and output it. + Enc: on input k and a message \\(m \\in \\{0, 1\\}^n\\), choose uniform \\(r \\in \\{0, 1\\}^n\\) and output the ciphertext: $$ c :=  $$ + Dec: on input a k and a ciphertext \\(c = &lt;r, s&gt;\\), output the message $$ m := F_k\u00ae \\oplus s $$ <ul> <li>Theorem: If F is a pseudorandom function, then Construction above is a CPA-secure, fixed-length private-key encryption scheme for messages of length n.</li> </ul> <p>Proof: \u200b\u7b49\u200b\u6211\u200b\u770b\u200b\u61c2\u200b\u4e86\u200b\u518d\u200b\u5199\u200b()\uff08\u200b\u4e0e\u5176\u8bf4\u200b\u6ca1\u770b\u200b\u61c2\u200b\u4e0d\u5982\u8bf4\u200b\u8fd8\u200b\u6ca1\u200b\u6765\u5f97\u53ca\u200b\u770b\u200b()\uff09</p>"},{"location":"cryption/C3/#modes-of-operation-and-encryption-in-practice","title":"Modes of Operation and Encryption in Practice","text":"<p>Solve the question pseudorandom function for CPA that the length of the ciphertext is constant multiple of the plaintext and pseudorandom generator for EAV that the message length must to be fixed length.</p>"},{"location":"cryption/C3/#stream-ciphers","title":"Stream Ciphers","text":"<p>When we use pseudorandom generator G in EAV, it is not easy to encrypt the message whose length is longer than the expansion factor, and it is wasted when we encrypt the message whose length is shorter than expansion factor.</p> <p>Stream Ciphers is used to instantiate pseudorandom generators, provide greater flexibility. </p> <p>A stream cipher is a pair of deterministic algorithms: 1. Init takes as input a seed s and an optional initialization vector IV, and outputs some initial state st. 2. Next takes as input a current state st and outputs a bit y along with updated state st'. 3. We difine an algorithm GetBits that takes as input an initial state \\(st_0\\) and a desired output length \\(1^l\\)(specified in unary, since GetBits runs in time linear in l):     1. For i = 1 to l, compute \\((y_i, st_i) := Next(st_{i-1})\\).     2. Return the l-bit string \\(y = y_1...y_l\\) as well as the final state \\(st_l\\).  \\(\\(st_0 \\rightarrow (y_1, st_1) \\overset{st_1}{\\rightarrow} (y_2, st_2) \\overset{st_2}{\\rightarrow} ... \\overset{st_{n-1}}{\\rightarrow} (y_n, st_n)\\)\\)</p> <pre><code>  We let $GetBits_1$ be the algorithm that runs GetBits and only returns its initial output(the l-bit y).\n</code></pre> <p>Without the IV, stream cipher is just a pseudorandom generator that is more reflexible. Define a deterministic \\(G^l\\):    \\(\\(G^l(s) = GetBits_1(Init(s), 1^l)\\)\\)</p> <p>A stream cipher takes an IV can be defined in multiple ways. We define security in this case a pseudorandom function.  + Choose a uniform seed s and then run Init(s,\u00b7) repeatedly using the different values for the IV (the requirement is that running \\(GetBits_1\\) using the different initial states should produce output streams that appear independently uniform). + We define the keyed function \\(F^l : \\{0 ,1\\}^n \\times \\{0, 1\\}^n \\rightarrow \\{0, 1\\}^l\\) given parameter l as follows:   \\(\\(F^l_s(IV) \\overset{def}{=} GetBits_1(Init(s, IV), 1^l)\\)\\)</p> <p>Stream cipher typically do not support arbitrary values of n, but work only for some fixed values of n. So concrete definition is more approriate.</p> <ul> <li>Constructing stream ciphers from pseudorandom functions:<ul> <li>use the seed s for the stream cipher as a key for F, </li> <li>evaluate \\(F_s\\) on a sequence of consecutive inputs starting from a value determined by IV.</li> </ul> </li> </ul> <p>Construction 3.30</p> <p>Let F be a pseudorandom function. Define a stream cipher (Init, Next) as follows, where Init accepts a \\(3n/4\\)-bit initialization vector and Next outputs n bits in each call: + Init: on input \\(s \\in \\{0, 1\\}^n\\) and \\(IV \\in \\{0, 1\\}^{3n/4}\\), output st = (s, IV, 0) + Next: on input st = (s, IV, i), output \\(y := F_s(IV||&lt;i&gt;)\\) and updated state st' = (s, IV, i + 1)</p>"},{"location":"cryption/C3/#stream-cipher-modes-of-operation","title":"Stream-Cipher Modes of Operation","text":"<ul> <li> <p>Synchronized mode: </p> <ol> <li>Both parties call Init(k) to obtain the same initial state \\(st_0\\)</li> <li>Let \\(st_S\\) be the current state of S (sender). If S wants to encrypt the message m, it computes \\((y,st'_S) := GetBits(st_S, 1^{|m|})\\) (st' is the final state and y is the message encrypted), sends \\(c := m \\oplus y\\) to the reciever, and updates its local state to \\(st'_S\\)</li> <li>Let \\(st_R\\) be the current state of reciever R. When R recieves the ciphertext c from the sender, it computes \\((y, st'_R) = GetBits(st_R, 1^{|c|})\\), outputs the message \\(m := c \\oplus y\\), and updates its own local state. <p>The two parties can achieve the bidirectional communication after sending the first key. Mention that the above stream cipher has no ciphertext expansion, and need no IV. It is a stateful mode which need to store the final state.</p> </li> </ol> </li> <li> <p>Unsynchronized mode: Use IV can construct a stateless encryption scheme that is analogous to Construction 3.28. The main advantage is that encryption scheme directly handles arbitrary-length messages.</p> </li> </ul> <p>Construction 3.31</p> <p>Let (Init, Next) be a stream cipher that takes an n-bit IV. Define a private-key encryption scheme for arbitrary-length messages as follows: + Gen: on input \\(1^n\\), choose a uniform \\(k \\in \\{0, 1\\}^n\\) and output k. + Enc: on input key and message \\(m \\in \\{0, 1\\}^*\\), choose uniform \\(IV \\in \\{0, 1\\}^n\\), and output the ciphertext $$  $$ + Dec: on input a key and ciphertext \\(&lt;IV, c&gt;\\), output the message $$ m := GetBits_1(Init(k, IV), 1^{|c|}) \\oplus c $$"},{"location":"cryption/C3/#block-ciphers-and-block-cipher-modes-of-operation","title":"Block Ciphers and Block-Cipher Modes of Operation","text":""}]}